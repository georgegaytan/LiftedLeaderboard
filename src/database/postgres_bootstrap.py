import logging

from src.database.db_manager import DBManager

logger = logging.getLogger(__name__)


def init_schema_pg(db: DBManager) -> None:
    '''Create Postgres schema, indexes, and triggers equivalent to the SQLite setup.'''
    # USERS
    db.execute('''
        CREATE TABLE IF NOT EXISTS users (
            id BIGINT PRIMARY KEY,
            display_name TEXT NOT NULL,
            total_xp INTEGER NOT NULL DEFAULT 0,
            level INTEGER NOT NULL DEFAULT 1,
            created_at TIMESTAMPTZ DEFAULT NOW(),
            updated_at TIMESTAMPTZ DEFAULT NOW()
        )
        ''')

    # ACTIVITIES
    db.execute('''
        CREATE TABLE IF NOT EXISTS activities (
            id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            name TEXT UNIQUE NOT NULL,
            category TEXT NOT NULL,
            xp_value INTEGER NOT NULL DEFAULT 0,
            is_archived BOOLEAN NOT NULL DEFAULT FALSE,
            created_at TIMESTAMPTZ DEFAULT NOW(),
            updated_at TIMESTAMPTZ DEFAULT NOW()
        )
        ''')

    # ACTIVITY RECORDS
    db.execute('''
        CREATE TABLE IF NOT EXISTS activity_records (
            id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            user_id BIGINT NOT NULL,
            activity_id INTEGER NOT NULL,
            note TEXT NULL,
            date_occurred DATE DEFAULT CURRENT_DATE,
            created_at TIMESTAMPTZ DEFAULT NOW(),
            updated_at TIMESTAMPTZ DEFAULT NOW(),
            CONSTRAINT fk_ar_user FOREIGN KEY (user_id)
                REFERENCES users(id) ON DELETE CASCADE,
            CONSTRAINT fk_ar_activity FOREIGN KEY (activity_id)
                REFERENCES activities(id)
        )
        ''')

    # LEVEL THRESHOLDS
    db.execute('''
        CREATE TABLE IF NOT EXISTS level_thresholds (
            level INTEGER PRIMARY KEY,
            xp_required INTEGER NOT NULL
        )
        ''')

    # MIGRATIONS
    db.execute('''
        CREATE TABLE IF NOT EXISTS migrations (
            id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            filename TEXT NOT NULL UNIQUE,
            applied_at TIMESTAMPTZ DEFAULT NOW()
        )
        ''')

    # INDEXES
    db.execute('''
        CREATE INDEX IF NOT EXISTS idx_activity_records_user_id
        ON activity_records(user_id)
        ''')
    db.execute('''
        CREATE INDEX IF NOT EXISTS idx_activity_records_activity_id
        ON activity_records(activity_id)
        ''')
    db.execute('''
        CREATE INDEX IF NOT EXISTS idx_activity_records_created_at
        ON activity_records(created_at)
        ''')
    db.execute('''
        CREATE INDEX IF NOT EXISTS idx_activity_records_updated_at
        ON activity_records(updated_at)
        ''')
    db.execute('''
        CREATE INDEX IF NOT EXISTS idx_activity_records_date_occurred
        ON activity_records(date_occurred)
        ''')

    # TRIGGERS: updated_at auto-update via BEFORE UPDATE
    db.execute('''
        CREATE OR REPLACE FUNCTION set_updated_at()
        RETURNS TRIGGER AS $$
        BEGIN
            NEW.updated_at := NOW();
            RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
        ''')
    for tbl in ('users', 'activities', 'activity_records'):
        db.execute(f'''
            DO $$ BEGIN
                IF NOT EXISTS (
                    SELECT 1 FROM pg_trigger WHERE tgname = 'trg_{tbl}_set_updated_at'
                ) THEN
                    CREATE TRIGGER trg_{tbl}_set_updated_at
                    BEFORE UPDATE ON {tbl}
                    FOR EACH ROW
                    EXECUTE FUNCTION set_updated_at();
                END IF;
            END $$;
            ''')

    # TRIGGER: award XP on insert
    db.execute('''
        CREATE OR REPLACE FUNCTION award_activity_xp_fn()
        RETURNS TRIGGER AS $$
        DECLARE
            v_xp INTEGER;
        BEGIN
            SELECT xp_value INTO v_xp FROM activities WHERE id = NEW.activity_id;
            IF v_xp IS NULL THEN
                v_xp := 0;
            END IF;
            UPDATE users
            SET total_xp = total_xp + v_xp,
                updated_at = NOW()
            WHERE id = NEW.user_id;
            RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
        ''')
    db.execute('''
        DO $$ BEGIN
            IF NOT EXISTS (
                SELECT 1 FROM pg_trigger WHERE tgname = 'trg_award_activity_xp'
            ) THEN
                CREATE TRIGGER trg_award_activity_xp
                AFTER INSERT ON activity_records
                FOR EACH ROW
                EXECUTE FUNCTION award_activity_xp_fn();
            END IF;
        END $$;
        ''')

    # TRIGGER: adjust XP on update of activity_id
    db.execute('''
        CREATE OR REPLACE FUNCTION adjust_activity_xp_on_update_fn()
        RETURNS TRIGGER AS $$
        DECLARE
            old_xp INTEGER;
            new_xp INTEGER;
        BEGIN
            IF OLD.activity_id IS DISTINCT FROM NEW.activity_id THEN
                SELECT xp_value INTO old_xp FROM activities WHERE id = OLD.activity_id;
                SELECT xp_value INTO new_xp FROM activities WHERE id = NEW.activity_id;
                IF old_xp IS NULL THEN old_xp := 0; END IF;
                IF new_xp IS NULL THEN new_xp := 0; END IF;
                UPDATE users
                SET total_xp = total_xp - old_xp + new_xp,
                    updated_at = NOW()
                WHERE id = NEW.user_id;
            END IF;
            RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
        ''')
    db.execute('''
        DO $$ BEGIN
            IF NOT EXISTS (
                SELECT 1 FROM pg_trigger
                WHERE tgname = 'trg_adjust_activity_xp_on_update'
            ) THEN
                CREATE TRIGGER trg_adjust_activity_xp_on_update
                AFTER UPDATE OF activity_id ON activity_records
                FOR EACH ROW
                EXECUTE FUNCTION adjust_activity_xp_on_update_fn();
            END IF;
        END $$;
        ''')

    # TRIGGER: revoke XP on delete
    db.execute('''
        CREATE OR REPLACE FUNCTION revoke_activity_xp_on_delete_fn()
        RETURNS TRIGGER AS $$
        DECLARE
            old_xp INTEGER;
        BEGIN
            SELECT xp_value INTO old_xp FROM activities WHERE id = OLD.activity_id;
            IF old_xp IS NULL THEN old_xp := 0; END IF;
            UPDATE users
            SET total_xp = total_xp - old_xp,
                updated_at = NOW()
            WHERE id = OLD.user_id;
            RETURN OLD;
        END;
        $$ LANGUAGE plpgsql;
        ''')
    db.execute('''
        DO $$ BEGIN
            IF NOT EXISTS (
                SELECT 1 FROM pg_trigger
                WHERE tgname = 'trg_revoke_activity_xp_on_delete'
            ) THEN
                CREATE TRIGGER trg_revoke_activity_xp_on_delete
                AFTER DELETE ON activity_records
                FOR EACH ROW
                EXECUTE FUNCTION revoke_activity_xp_on_delete_fn();
            END IF;
        END $$;
        ''')

    # TRIGGER: update user level when total_xp changes
    db.execute('''
        CREATE OR REPLACE FUNCTION update_user_level_on_xp_change_fn()
        RETURNS TRIGGER AS $$
        DECLARE
            new_level INTEGER;
        BEGIN
            SELECT COALESCE(MAX(level), 1) INTO new_level
            FROM level_thresholds
            WHERE xp_required <= NEW.total_xp;

            IF new_level IS NULL THEN new_level := 1; END IF;

            IF NEW.level IS DISTINCT FROM new_level THEN
                UPDATE users
                SET level = new_level,
                    updated_at = NOW()
                WHERE id = NEW.id;
            END IF;
            RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
        ''')
    db.execute('''
        DO $$ BEGIN
            IF NOT EXISTS (
                SELECT 1 FROM pg_trigger
                WHERE tgname = 'trg_update_user_level_on_xp_change'
            ) THEN
                CREATE TRIGGER trg_update_user_level_on_xp_change
                AFTER UPDATE OF total_xp ON users
                FOR EACH ROW
                EXECUTE FUNCTION update_user_level_on_xp_change_fn();
            END IF;
        END $$;
        ''')

    logger.info('Postgres schema, indexes, and triggers ensured.')
